<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Robot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(15, 23, 42, 0.8);
            z-index: 100;
            transition: opacity 1s;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: 'Arial', sans-serif;
            background-color: rgba(15, 23, 42, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 3px solid #3b82f6;
        }
    </style>
</head>
<body class="bg-slate-900 text-white">
    <div id="loading">
        <div class="loading-spinner"></div>
    </div>
    
    <div id="ui" class="hidden">
        <h2 class="text-lg font-bold mb-2">Interactive Robot</h2>
        <p class="text-sm">Move your cursor to control the robot</p>
    </div>
    
    <script>
        // Wait for everything to load
        window.addEventListener('load', init);
        
        let scene, camera, renderer, robot, mixer, clock;
        let targetPosition = { x: 0, y: 0, z: 0 };
        let mouse = { x: 0, y: 0 };
        let isMobile = false;
        
        function init() {
            // Check if mobile
            isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            scene.fog = new THREE.FogExp2(0x0f172a, 0.002);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0x3b82f6, 0x10b981, 0.3);
            scene.add(hemisphereLight);
            
            // Add ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1e293b,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 100, 0x334155, 0x334155);
            scene.add(gridHelper);
            
            // Create robot
            createRobot();
            
            // Mouse move event
            window.addEventListener('mousemove', onMouseMove);
            
            // Touch move event for mobile
           if (isMobile) {
    window.addEventListener('touchstart', onTouchMove, { passive: false });
    window.addEventListener('touchmove', onTouchMove, { passive: false });
    window.addEventListener('touchend', () => {
        targetPosition.x = 0;
        targetPosition.z = 0;
    });
}
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Animation clock
            clock = new THREE.Clock();
            
            // Hide loading screen when ready
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
                document.getElementById('ui').classList.remove('hidden');
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }, 1500);
            
            // Start animation loop
            animate();
        }
        
        function createRobot() {
            // Robot parts
            const bodyGeometry = new THREE.BoxGeometry(2, 3, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x334155,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.position.y = 1.5;
            
            const headGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x475569,
                metalness: 0.8,
                roughness: 0.2
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.castShadow = true;
            head.position.y = 3.5;
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 3.5, 0.7);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 3.5, 0.7);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 16);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x475569 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-1.5, 2, 0);
            leftArm.rotation.z = Math.PI / 4;
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(1.5, 2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x334155 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.5, -1, 0);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.5, -1, 0);
            
            // Create robot group
            robot = new THREE.Group();
            robot.add(body);
            robot.add(head);
            robot.add(leftEye);
            robot.add(rightEye);
            robot.add(leftArm);
            robot.add(rightArm);
            robot.add(leftLeg);
            robot.add(rightLeg);
            robot.castShadow = true;
            
            // Add to scene
            scene.add(robot);
            
            // Create animation mixer for the robot
            mixer = new THREE.AnimationMixer(robot);
        }
        
        function onMouseMove(event) {
            // Normalize mouse position to -1 to 1 range
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update target position based on mouse
            targetPosition.x = mouse.x * 10;
            targetPosition.z = mouse.y * 10;
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            
            // Normalize touch position to -1 to 1 range
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            // Update target position based on touch
            targetPosition.x = mouse.x * 10;
            targetPosition.z = mouse.y * 10;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Smoothly move robot toward target position
            if (robot) {
                robot.position.x += (targetPosition.x - robot.position.x) * 0.05;
                robot.position.z += (targetPosition.z - robot.position.z) * 0.05;
                
                // Make robot look at target position
                robot.lookAt(new THREE.Vector3(
                    targetPosition.x,
                    robot.position.y,
                    targetPosition.z
                ));
                
                // Simple walking animation
                const time = clock.getElapsedTime();
                robot.children[4].rotation.z = Math.PI / 4 + Math.sin(time * 5) * 0.2; // Left arm
                robot.children[5].rotation.z = -Math.PI / 4 + Math.sin(time * 5) * 0.2; // Right arm
                robot.children[6].position.y = -1 + Math.sin(time * 5) * 0.1; // Left leg
                robot.children[7].position.y = -1 + Math.cos(time * 5) * 0.1; // Right leg
            }
            
            // Update animation mixer
            if (mixer) {
                mixer.update(delta);
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>